{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Meggie \u00b6 Meggie is an open-source software designed for intuitive MEG and EEG analysis. With its user-friendly graphical interface, Meggie brings the powerful analysis methods of MNE-Python to researchers without requiring programming skills. Key Features \u00b6 Cross-Platform : Runs on Linux, macOS, and Windows. User-Friendly : Simple graphical user interface for ease of use. Efficient Workflows : Supports multi-subject experiments and pipeline processing for streamlined analysis. Get started with Meggie and explore its features to simplify your MEG/EEG analysis. Getting Started","title":"Home"},{"location":"#welcome-to-meggie","text":"Meggie is an open-source software designed for intuitive MEG and EEG analysis. With its user-friendly graphical interface, Meggie brings the powerful analysis methods of MNE-Python to researchers without requiring programming skills.","title":"Welcome to Meggie"},{"location":"#key-features","text":"Cross-Platform : Runs on Linux, macOS, and Windows. User-Friendly : Simple graphical user interface for ease of use. Efficient Workflows : Supports multi-subject experiments and pipeline processing for streamlined analysis. Get started with Meggie and explore its features to simplify your MEG/EEG analysis. Getting Started","title":"Key Features"},{"location":"about/","text":"About Meggie \u00b6 Developed at the Jyv\u00e4skyl\u00e4 Centre for Interdisciplinary Brain Research (CIBR), Meggie is the result of a project that started in 2013, with the mission to make sophisticated M/EEG analysis accessible to all researchers. Meggie builds upon the MNE-Python library to deliver a robust set of features through an intuitive interface. Design Philosophy \u00b6 Meggie focuses on: Multi-Subject Management : It makes it easy to work with many subjects' data at once. Clear Analysis Steps : It helps users go step by step from starting data to results. Compared to other tools like FieldTrip, MNE-Python, EEGLAB, Brainstorm, and MNELAB, Meggie is unique because it's built with Python, it's easy for anyone to use, and it's designed for handling multiple subjects' data efficiently. Plugins \u00b6 Meggie can be changed and added to with plugins. If you know Python, you can create new features. This helps Meggie grow and helps everyone who uses it. To learn more, see our Developer Documentation .","title":"About"},{"location":"about/#about-meggie","text":"Developed at the Jyv\u00e4skyl\u00e4 Centre for Interdisciplinary Brain Research (CIBR), Meggie is the result of a project that started in 2013, with the mission to make sophisticated M/EEG analysis accessible to all researchers. Meggie builds upon the MNE-Python library to deliver a robust set of features through an intuitive interface.","title":"About Meggie"},{"location":"about/#design-philosophy","text":"Meggie focuses on: Multi-Subject Management : It makes it easy to work with many subjects' data at once. Clear Analysis Steps : It helps users go step by step from starting data to results. Compared to other tools like FieldTrip, MNE-Python, EEGLAB, Brainstorm, and MNELAB, Meggie is unique because it's built with Python, it's easy for anyone to use, and it's designed for handling multiple subjects' data efficiently.","title":"Design Philosophy"},{"location":"about/#plugins","text":"Meggie can be changed and added to with plugins. If you know Python, you can create new features. This helps Meggie grow and helps everyone who uses it. To learn more, see our Developer Documentation .","title":"Plugins"},{"location":"developer-guide/architecture/","text":"Architecture Overview \u00b6 This document outlines the core structure of Meggie, offering insights into its construction and how developers can leverage its architecture. Main Classes \u00b6 Meggie is structured around three fundamental classes: MainWindow \u00b6 MainWindow is the central hub of the user interface, built using PyQt. Key components include: Left Panel: Displays experiment-specific details. Bottom Console: Logs user actions and system messages. Right Panel: Hosts tabs for data transformation actions. Experiment \u00b6 The Experiment class serves as the top-level container for all data, handling the saving and loading of experiments, and maintaining a collection of subjects. Subject \u00b6 Subject instances are nested within experiments and are tasked with managing subject-specific data. Their primary roles are to handle the saving and loading of raw data and to hold instances of various datatypes. Actions, Pipelines, and Datatypes \u00b6 Meggie's analytical capabilities are structured into actions, pipelines, and datatypes. Datatypes \u00b6 Datatypes are templates for summarizing raw data into meaningful structures for analysis, such as epochs, evokeds, spectrums, and TFRs. These templates are defined within the datatypes folder and instantiated as needed to store within subjects. Actions \u00b6 Actions represent fundamental analysis steps, like \"filter\" or \"create epochs.\" Each action, located in its respective folder within the actions directory, comprises metadata in configuration.json and Python code. Actions inherit from the Action class in mainwindow/dynamic.py and can be integrated into pipelines and are automatically logged. Pipelines \u00b6 Pipelines organize actions into a sequence represented as buttons within the GUI tabs. They guide the user through a complete analysis workflow, such as \"Sensor-level continuous data analysis.\" Pipelines are specified in the main configuration.json and rely on actions for implementation, thus containing no Python code themselves. Plugins \u00b6 Creating plugins for Meggie is designed to be straightforward. The system dynamically locates pipelines, datatypes, and actions at runtime, allowing them to be loaded from external Python packages within the Meggie namespace. To create a plugin, one simply needs to develop a Python package named within the Meggie namespace that introduces new pipelines, actions, and/or datatypes. API \u00b6 The core of Meggie, excluding the actions, is intended to be stable and reusable. Plugin developers are encouraged to utilize the API provided by the MainWindow, Subject, and Experiment classes. Additionally, developers have access to the four datatypes in the datatypes folder and various utilities, including functions, dialogs, and widgets, found in the utilities folder.","title":"Architecture"},{"location":"developer-guide/architecture/#architecture-overview","text":"This document outlines the core structure of Meggie, offering insights into its construction and how developers can leverage its architecture.","title":"Architecture Overview"},{"location":"developer-guide/architecture/#main-classes","text":"Meggie is structured around three fundamental classes:","title":"Main Classes"},{"location":"developer-guide/architecture/#mainwindow","text":"MainWindow is the central hub of the user interface, built using PyQt. Key components include: Left Panel: Displays experiment-specific details. Bottom Console: Logs user actions and system messages. Right Panel: Hosts tabs for data transformation actions.","title":"MainWindow"},{"location":"developer-guide/architecture/#experiment","text":"The Experiment class serves as the top-level container for all data, handling the saving and loading of experiments, and maintaining a collection of subjects.","title":"Experiment"},{"location":"developer-guide/architecture/#subject","text":"Subject instances are nested within experiments and are tasked with managing subject-specific data. Their primary roles are to handle the saving and loading of raw data and to hold instances of various datatypes.","title":"Subject"},{"location":"developer-guide/architecture/#actions-pipelines-and-datatypes","text":"Meggie's analytical capabilities are structured into actions, pipelines, and datatypes.","title":"Actions, Pipelines, and Datatypes"},{"location":"developer-guide/architecture/#datatypes","text":"Datatypes are templates for summarizing raw data into meaningful structures for analysis, such as epochs, evokeds, spectrums, and TFRs. These templates are defined within the datatypes folder and instantiated as needed to store within subjects.","title":"Datatypes"},{"location":"developer-guide/architecture/#actions","text":"Actions represent fundamental analysis steps, like \"filter\" or \"create epochs.\" Each action, located in its respective folder within the actions directory, comprises metadata in configuration.json and Python code. Actions inherit from the Action class in mainwindow/dynamic.py and can be integrated into pipelines and are automatically logged.","title":"Actions"},{"location":"developer-guide/architecture/#pipelines","text":"Pipelines organize actions into a sequence represented as buttons within the GUI tabs. They guide the user through a complete analysis workflow, such as \"Sensor-level continuous data analysis.\" Pipelines are specified in the main configuration.json and rely on actions for implementation, thus containing no Python code themselves.","title":"Pipelines"},{"location":"developer-guide/architecture/#plugins","text":"Creating plugins for Meggie is designed to be straightforward. The system dynamically locates pipelines, datatypes, and actions at runtime, allowing them to be loaded from external Python packages within the Meggie namespace. To create a plugin, one simply needs to develop a Python package named within the Meggie namespace that introduces new pipelines, actions, and/or datatypes.","title":"Plugins"},{"location":"developer-guide/architecture/#api","text":"The core of Meggie, excluding the actions, is intended to be stable and reusable. Plugin developers are encouraged to utilize the API provided by the MainWindow, Subject, and Experiment classes. Additionally, developers have access to the four datatypes in the datatypes folder and various utilities, including functions, dialogs, and widgets, found in the utilities folder.","title":"API"},{"location":"developer-guide/development/","text":"Development \u00b6 Setting up \u00b6 For an example of a basic plugin template, please visit Meggie Simple Plugin on GitHub. Actions, pipelines, and datatypes function identically, regardless of whether they originate from a plugin or from the core of Meggie. Therefore, examining the implementations within the Meggie repository is advisable for understanding their integration and usage.","title":"Development"},{"location":"developer-guide/development/#development","text":"","title":"Development"},{"location":"developer-guide/development/#setting-up","text":"For an example of a basic plugin template, please visit Meggie Simple Plugin on GitHub. Actions, pipelines, and datatypes function identically, regardless of whether they originate from a plugin or from the core of Meggie. Therefore, examining the implementations within the Meggie repository is advisable for understanding their integration and usage.","title":"Setting up"},{"location":"user-guide/actions/","text":"Actions \u00b6 Actions serve as the primary analytical tools within Meggie. Upon establishing an experiment and incorporating the raw data files for each subject, these actions are systematically employed to progressively convert the raw magnetic or electric signals into meaningful behavioral outcomes. Below is a catalog of the available actions along with their respective descriptions. Preprocessing \u00b6 Events from annotations (raw_events_from_annotations) \u00b6 Create events from annotations for further analysis. The following MNE functions are used: - mne.utils.config._get_stim_channel - raw.load_data - raw.save Filter (raw_filter) \u00b6 Apply low-pass, high-pass, band-pass, and band-stop filters to raw data to isolate specific frequency ranges or remove unwanted frequencies. The following MNE functions are used: - raw.filter - raw.load_data - raw.save Artifact removal (raw_ica) \u00b6 Apply Independent Component Analysis (ICA) to raw data to identify and remove artifacts such as heartbeats and eye blinks. The following MNE functions are used: - ica.apply - ica.fit - ica.get_sources - ica.plot_components - ica.plot_properties - mne.create_info - mne.io.RawArray - mne.preprocessing.ICA - raw.drop_channels - raw.load_data - raw.plot - raw.save Montage (raw_montage) \u00b6 Apply a montage to the EEG dataset, enabling the creation of topographical plots. The following MNE functions are used: - mne.channels.make_standard_montage - montage.save - raw.load_data - raw.save Plot raw (raw_plot) \u00b6 Produce a time series plot of the raw data. The following MNE functions are used: - mne.find_events - mne.utils.config._get_stim_channel - raw.load_data - raw.plot Plot projections (raw_plot_projections) \u00b6 Generate a plot to visualize the projection vectors contained within the raw data. The following MNE functions are used: - raw.load_data - raw.plot_projs_topomap Rereference (raw_rereference) \u00b6 Re-reference the raw data to an average reference, which can be computed from one or more selected channels or all channels. The following MNE functions are used: - mne.pick_types - raw.load_data - raw.save Resample (raw_resample) \u00b6 Adjust the dataset by resampling it to a different sampling frequency. The following MNE functions are used: - raw.load_data - raw.resample - raw.save Continuous data \u00b6 Create spectrum (spectrum_create) \u00b6 Calculate the spectral data at specified time intervals for the current subject. The following MNE functions are used: - mne.io.write_info - mne.pick_info - mne.pick_types - mne_spectrum.get_data - raw.compute_psd - raw.load_data Delete (spectrum_delete) \u00b6 Permanently remove the selected spectrum object from the current subject. Delete from all (spectrum_delete_from_all) \u00b6 Permanently remove the selected spectrum object from all matching subjects. Average over subjects (spectrum_group_average) \u00b6 Calculate the average of the selected spectrum object across subjects, with options to group subjects before averaging. The following MNE functions are used: - mne.io.write_info - mne.pick_info Plot (spectrum_plot) \u00b6 Generate a plot for the selected spectrum object. The spectrum object may be visualized for all channels individually or as an average across specified channel groups. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types - mne.viz.iter_topography - raw.load_data Save to csv (spectrum_save) \u00b6 Export the numerical data from the spectrum object for all matching subjects into a CSV file. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types Epochs \u00b6 Create epochs (epochs_create) \u00b6 Create a new epoch collection for the current subject. The following MNE functions are used: - epochs.get_data - epochs.save - mne.Epochs - mne.find_events - mne.pick_types - mne.utils.config._get_stim_channel - raw.load_data Delete (epochs_delete) \u00b6 Permanently remove the selected epoch collection from the current subject. Delete from all (epochs_delete_from_all) \u00b6 Permanently remove the selected epoch collection from all matching subjects. Plot (epochs_plot) \u00b6 Generate a simple plot for the selected epoch collection. The following MNE functions are used: - epochs.plot Plot image (epochs_plot_image) \u00b6 Generate an image plot for the selected epoch collection. The following MNE functions are used: - epochs.plot_image Evoked responses \u00b6 Create evoked (evoked_create) \u00b6 Compute the average of selected epoch collections independently. Each collection is averaged separately, resulting in a distinct average curve for each. The following MNE functions are used: - epochs.average - mne.write_evokeds Delete (evoked_delete) \u00b6 Permanently remove the selected evoked response object from the current subject. Delete from all (evoked_delete_from_all) \u00b6 Permanently remove the selected evoked response object from all matching subjects. Average over subjects (evoked_group_average) \u00b6 Calculate the average of the selected evoked response object across subjects, with options to group subjects before averaging. The following MNE functions are used: - mne.grand_average - mne.pick_types - mne.write_evokeds Plot (evoked_plot) \u00b6 Generate a plot for the selected evoked response object. The response may be visualized for all channels individually or as an average across specified channel groups. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types - mne.viz.plot_evoked_topo Plot topomaps (evoked_plot_topomap) \u00b6 Produce a series of topographical maps at specified time intervals for the selected evoked response object. The following MNE functions are used: - evoked.plot_topomap - mne.pick_types Save to csv (evoked_save) \u00b6 Export the numerical data from the evoked response object for all matching subjects into a CSV file. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types Induced responses (TFR) \u00b6 Create TFR (tfr_create) \u00b6 Calculate time-frequency representations (TFRs) for selected epoch collections independently, with each collection yielding a unique TFR. The following MNE functions are used: - epochs.compute_tfr - tfr.save Delete (tfr_delete) \u00b6 Permanently remove the selected TFR object from the current subject. Delete from all (tfr_delete_from_all) \u00b6 Permanently remove the selected TFR object from all matching subjects. Average over subjects (tfr_group_average) \u00b6 Calculate the average of the selected TFR object across subjects, with options to group subjects before averaging. The following MNE functions are used: - mne.grand_average - tfr.save Plot TFR (tfr_plot) \u00b6 Visualize the selected TFR object as a heatmap, with options for individual channel visualization or averaging across channel groups. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.create_info - mne.pick_info - mne.pick_types - mne.time_frequency.tfr.AverageTFRArray - tfr.apply_baseline - tfr.plot - tfr.plot_topo Plot TSE (tfr_plot_tse) \u00b6 Visualize the Temporal Spectral Evolution (TSE) of the selected TFR object, collapsing the frequency dimension over a specified interval, for individual channels or averaged across channel groups. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types - mne.viz.iter_topography Save TFR to csv (tfr_save) \u00b6 Export the numerical data from the TFR object for all matching subjects into a CSV file. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types Save TSE to csv (tfr_save_tse) \u00b6 Export the TSE data from the TFR object, collapsing the frequency dimension over a specified interval, into a CSV file for all matching subjects. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types","title":"Actions"},{"location":"user-guide/actions/#actions","text":"Actions serve as the primary analytical tools within Meggie. Upon establishing an experiment and incorporating the raw data files for each subject, these actions are systematically employed to progressively convert the raw magnetic or electric signals into meaningful behavioral outcomes. Below is a catalog of the available actions along with their respective descriptions.","title":"Actions"},{"location":"user-guide/actions/#preprocessing","text":"","title":"Preprocessing"},{"location":"user-guide/actions/#events-from-annotations-raw_events_from_annotations","text":"Create events from annotations for further analysis. The following MNE functions are used: - mne.utils.config._get_stim_channel - raw.load_data - raw.save","title":"Events from annotations (raw_events_from_annotations)"},{"location":"user-guide/actions/#filter-raw_filter","text":"Apply low-pass, high-pass, band-pass, and band-stop filters to raw data to isolate specific frequency ranges or remove unwanted frequencies. The following MNE functions are used: - raw.filter - raw.load_data - raw.save","title":"Filter (raw_filter)"},{"location":"user-guide/actions/#artifact-removal-raw_ica","text":"Apply Independent Component Analysis (ICA) to raw data to identify and remove artifacts such as heartbeats and eye blinks. The following MNE functions are used: - ica.apply - ica.fit - ica.get_sources - ica.plot_components - ica.plot_properties - mne.create_info - mne.io.RawArray - mne.preprocessing.ICA - raw.drop_channels - raw.load_data - raw.plot - raw.save","title":"Artifact removal (raw_ica)"},{"location":"user-guide/actions/#montage-raw_montage","text":"Apply a montage to the EEG dataset, enabling the creation of topographical plots. The following MNE functions are used: - mne.channels.make_standard_montage - montage.save - raw.load_data - raw.save","title":"Montage (raw_montage)"},{"location":"user-guide/actions/#plot-raw-raw_plot","text":"Produce a time series plot of the raw data. The following MNE functions are used: - mne.find_events - mne.utils.config._get_stim_channel - raw.load_data - raw.plot","title":"Plot raw (raw_plot)"},{"location":"user-guide/actions/#plot-projections-raw_plot_projections","text":"Generate a plot to visualize the projection vectors contained within the raw data. The following MNE functions are used: - raw.load_data - raw.plot_projs_topomap","title":"Plot projections (raw_plot_projections)"},{"location":"user-guide/actions/#rereference-raw_rereference","text":"Re-reference the raw data to an average reference, which can be computed from one or more selected channels or all channels. The following MNE functions are used: - mne.pick_types - raw.load_data - raw.save","title":"Rereference (raw_rereference)"},{"location":"user-guide/actions/#resample-raw_resample","text":"Adjust the dataset by resampling it to a different sampling frequency. The following MNE functions are used: - raw.load_data - raw.resample - raw.save","title":"Resample (raw_resample)"},{"location":"user-guide/actions/#continuous-data","text":"","title":"Continuous data"},{"location":"user-guide/actions/#create-spectrum-spectrum_create","text":"Calculate the spectral data at specified time intervals for the current subject. The following MNE functions are used: - mne.io.write_info - mne.pick_info - mne.pick_types - mne_spectrum.get_data - raw.compute_psd - raw.load_data","title":"Create spectrum (spectrum_create)"},{"location":"user-guide/actions/#delete-spectrum_delete","text":"Permanently remove the selected spectrum object from the current subject.","title":"Delete (spectrum_delete)"},{"location":"user-guide/actions/#delete-from-all-spectrum_delete_from_all","text":"Permanently remove the selected spectrum object from all matching subjects.","title":"Delete from all (spectrum_delete_from_all)"},{"location":"user-guide/actions/#average-over-subjects-spectrum_group_average","text":"Calculate the average of the selected spectrum object across subjects, with options to group subjects before averaging. The following MNE functions are used: - mne.io.write_info - mne.pick_info","title":"Average over subjects (spectrum_group_average)"},{"location":"user-guide/actions/#plot-spectrum_plot","text":"Generate a plot for the selected spectrum object. The spectrum object may be visualized for all channels individually or as an average across specified channel groups. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types - mne.viz.iter_topography - raw.load_data","title":"Plot (spectrum_plot)"},{"location":"user-guide/actions/#save-to-csv-spectrum_save","text":"Export the numerical data from the spectrum object for all matching subjects into a CSV file. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types","title":"Save to csv (spectrum_save)"},{"location":"user-guide/actions/#epochs","text":"","title":"Epochs"},{"location":"user-guide/actions/#create-epochs-epochs_create","text":"Create a new epoch collection for the current subject. The following MNE functions are used: - epochs.get_data - epochs.save - mne.Epochs - mne.find_events - mne.pick_types - mne.utils.config._get_stim_channel - raw.load_data","title":"Create epochs (epochs_create)"},{"location":"user-guide/actions/#delete-epochs_delete","text":"Permanently remove the selected epoch collection from the current subject.","title":"Delete (epochs_delete)"},{"location":"user-guide/actions/#delete-from-all-epochs_delete_from_all","text":"Permanently remove the selected epoch collection from all matching subjects.","title":"Delete from all (epochs_delete_from_all)"},{"location":"user-guide/actions/#plot-epochs_plot","text":"Generate a simple plot for the selected epoch collection. The following MNE functions are used: - epochs.plot","title":"Plot (epochs_plot)"},{"location":"user-guide/actions/#plot-image-epochs_plot_image","text":"Generate an image plot for the selected epoch collection. The following MNE functions are used: - epochs.plot_image","title":"Plot image (epochs_plot_image)"},{"location":"user-guide/actions/#evoked-responses","text":"","title":"Evoked responses"},{"location":"user-guide/actions/#create-evoked-evoked_create","text":"Compute the average of selected epoch collections independently. Each collection is averaged separately, resulting in a distinct average curve for each. The following MNE functions are used: - epochs.average - mne.write_evokeds","title":"Create evoked (evoked_create)"},{"location":"user-guide/actions/#delete-evoked_delete","text":"Permanently remove the selected evoked response object from the current subject.","title":"Delete (evoked_delete)"},{"location":"user-guide/actions/#delete-from-all-evoked_delete_from_all","text":"Permanently remove the selected evoked response object from all matching subjects.","title":"Delete from all (evoked_delete_from_all)"},{"location":"user-guide/actions/#average-over-subjects-evoked_group_average","text":"Calculate the average of the selected evoked response object across subjects, with options to group subjects before averaging. The following MNE functions are used: - mne.grand_average - mne.pick_types - mne.write_evokeds","title":"Average over subjects (evoked_group_average)"},{"location":"user-guide/actions/#plot-evoked_plot","text":"Generate a plot for the selected evoked response object. The response may be visualized for all channels individually or as an average across specified channel groups. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types - mne.viz.plot_evoked_topo","title":"Plot (evoked_plot)"},{"location":"user-guide/actions/#plot-topomaps-evoked_plot_topomap","text":"Produce a series of topographical maps at specified time intervals for the selected evoked response object. The following MNE functions are used: - evoked.plot_topomap - mne.pick_types","title":"Plot topomaps (evoked_plot_topomap)"},{"location":"user-guide/actions/#save-to-csv-evoked_save","text":"Export the numerical data from the evoked response object for all matching subjects into a CSV file. The following MNE functions are used: - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types","title":"Save to csv (evoked_save)"},{"location":"user-guide/actions/#induced-responses-tfr","text":"","title":"Induced responses (TFR)"},{"location":"user-guide/actions/#create-tfr-tfr_create","text":"Calculate time-frequency representations (TFRs) for selected epoch collections independently, with each collection yielding a unique TFR. The following MNE functions are used: - epochs.compute_tfr - tfr.save","title":"Create TFR (tfr_create)"},{"location":"user-guide/actions/#delete-tfr_delete","text":"Permanently remove the selected TFR object from the current subject.","title":"Delete (tfr_delete)"},{"location":"user-guide/actions/#delete-from-all-tfr_delete_from_all","text":"Permanently remove the selected TFR object from all matching subjects.","title":"Delete from all (tfr_delete_from_all)"},{"location":"user-guide/actions/#average-over-subjects-tfr_group_average","text":"Calculate the average of the selected TFR object across subjects, with options to group subjects before averaging. The following MNE functions are used: - mne.grand_average - tfr.save","title":"Average over subjects (tfr_group_average)"},{"location":"user-guide/actions/#plot-tfr-tfr_plot","text":"Visualize the selected TFR object as a heatmap, with options for individual channel visualization or averaging across channel groups. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.create_info - mne.pick_info - mne.pick_types - mne.time_frequency.tfr.AverageTFRArray - tfr.apply_baseline - tfr.plot - tfr.plot_topo","title":"Plot TFR (tfr_plot)"},{"location":"user-guide/actions/#plot-tse-tfr_plot_tse","text":"Visualize the Temporal Spectral Evolution (TSE) of the selected TFR object, collapsing the frequency dimension over a specified interval, for individual channels or averaged across channel groups. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types - mne.viz.iter_topography","title":"Plot TSE (tfr_plot_tse)"},{"location":"user-guide/actions/#save-tfr-to-csv-tfr_save","text":"Export the numerical data from the TFR object for all matching subjects into a CSV file. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types","title":"Save TFR to csv (tfr_save)"},{"location":"user-guide/actions/#save-tse-to-csv-tfr_save_tse","text":"Export the TSE data from the TFR object, collapsing the frequency dimension over a specified interval, into a CSV file for all matching subjects. The following MNE functions are used: - mne.baseline.rescale - mne.channels._divide_to_regions - mne.pick_info - mne.pick_types","title":"Save TSE to csv (tfr_save_tse)"},{"location":"user-guide/experiments/","text":"Experiments in Meggie \u00b6 This section provides a straightforward overview of Meggie's layout and the steps for starting and managing experiments with subjects. Layout Overview \u00b6 Meggie's interface is organized into two main columns: Left Column: This area is your control panel for the experiment. Here, you add new subjects to your experiment and adjust settings like channel groups. It's the organizational hub for your data. Right Column: This column contains the analysis tools, referred to as actions, which you'll apply to your data. These tools are arranged in tabs and are used to process the data step by step. Starting an Experiment \u00b6 Begin by creating an experiment where you'll enter basic information such as the experiment's name and the person conducting it. You'll also choose a pipeline that fits your research needs. This helps keep the interface focused and guides you through the necessary steps. A folder for the experiment will be created to store all related files. Adding Subjects \u00b6 After setting up your experiment, you can add subjects, which are your individual recordings, using the \"Add new...\" option in the left column. Applying Actions \u00b6 In the right column, you'll find the actions you can apply to your data. These actions are designed to be used on all your subjects at once, making it efficient to process multiple datasets. Preprocessing \u00b6 Meggie includes basic preprocessing features to improve the quality of your data. You can remove unwanted noise and apply filters to clean up the signals before further analysis. Working with EEG and MEG Data \u00b6 Meggie is equipped to handle both EEG and MEG data. For EEG, it offers tools to add sensor locations and adjust channel references when necessary. Managing Events \u00b6 Events, which are significant points in your recordings, can be managed within Meggie. This ensures you have control over important data points for analysis. Progressing Through Analysis \u00b6 The goal is to transform raw recordings into data that can inform your research. You'll use actions to move through analysis stages, each tailored to bring out specific features of your data.","title":"Experiments"},{"location":"user-guide/experiments/#experiments-in-meggie","text":"This section provides a straightforward overview of Meggie's layout and the steps for starting and managing experiments with subjects.","title":"Experiments in Meggie"},{"location":"user-guide/experiments/#layout-overview","text":"Meggie's interface is organized into two main columns: Left Column: This area is your control panel for the experiment. Here, you add new subjects to your experiment and adjust settings like channel groups. It's the organizational hub for your data. Right Column: This column contains the analysis tools, referred to as actions, which you'll apply to your data. These tools are arranged in tabs and are used to process the data step by step.","title":"Layout Overview"},{"location":"user-guide/experiments/#starting-an-experiment","text":"Begin by creating an experiment where you'll enter basic information such as the experiment's name and the person conducting it. You'll also choose a pipeline that fits your research needs. This helps keep the interface focused and guides you through the necessary steps. A folder for the experiment will be created to store all related files.","title":"Starting an Experiment"},{"location":"user-guide/experiments/#adding-subjects","text":"After setting up your experiment, you can add subjects, which are your individual recordings, using the \"Add new...\" option in the left column.","title":"Adding Subjects"},{"location":"user-guide/experiments/#applying-actions","text":"In the right column, you'll find the actions you can apply to your data. These actions are designed to be used on all your subjects at once, making it efficient to process multiple datasets.","title":"Applying Actions"},{"location":"user-guide/experiments/#preprocessing","text":"Meggie includes basic preprocessing features to improve the quality of your data. You can remove unwanted noise and apply filters to clean up the signals before further analysis.","title":"Preprocessing"},{"location":"user-guide/experiments/#working-with-eeg-and-meg-data","text":"Meggie is equipped to handle both EEG and MEG data. For EEG, it offers tools to add sensor locations and adjust channel references when necessary.","title":"Working with EEG and MEG Data"},{"location":"user-guide/experiments/#managing-events","text":"Events, which are significant points in your recordings, can be managed within Meggie. This ensures you have control over important data points for analysis.","title":"Managing Events"},{"location":"user-guide/experiments/#progressing-through-analysis","text":"The goal is to transform raw recordings into data that can inform your research. You'll use actions to move through analysis stages, each tailored to bring out specific features of your data.","title":"Progressing Through Analysis"},{"location":"user-guide/getting-started/","text":"Getting Started \u00b6 Meggie can be installed on Windows, macOS, or Linux (Python 3.10+). Follow one of the three methods below. 1. Installing via uv \u00b6 Installation \u00b6 Meggie can be installed via uv with: $ uv tool install meggie == 1 .9.4 Running Meggie \u00b6 Simply run: meggie 2. Installing via pip \u00b6 Installation \u00b6 Create a virtual environment and install Meggie: python -m venv meggie-env source meggie-env/bin/activate pip install meggie == 1 .9.4 Running Meggie \u00b6 With the venv activated, run: meggie 3. Installing via conda \u00b6 Installation \u00b6 If conda is not already installed on your system, follow these steps: Visit the Miniconda download page: https://docs.conda.io/projects/conda Download the appropriate installer for your operating system: Windows : Miniconda3-latest-Windows-x86_64.exe Linux : Miniconda3-latest-Linux-x86_64.sh macOS : Miniconda3-latest-MacOSX-x86_64.pkg Run the downloaded installer and follow the on-screen instructions to complete the installation. Installing Meggie \u00b6 Create a new conda environment and install Meggie: conda create -n meggie-env -c conda-forge --solver libmamba meggie == 1 .9.4 conda activate meggie-env Running Meggie \u00b6 With the conda environment activated, run: meggie","title":"Getting Started"},{"location":"user-guide/getting-started/#getting-started","text":"Meggie can be installed on Windows, macOS, or Linux (Python 3.10+). Follow one of the three methods below.","title":"Getting Started"},{"location":"user-guide/getting-started/#1-installing-via-uv","text":"","title":"1. Installing via uv"},{"location":"user-guide/getting-started/#installation","text":"Meggie can be installed via uv with: $ uv tool install meggie == 1 .9.4","title":"Installation"},{"location":"user-guide/getting-started/#running-meggie","text":"Simply run: meggie","title":"Running Meggie"},{"location":"user-guide/getting-started/#2-installing-via-pip","text":"","title":"2. Installing via pip"},{"location":"user-guide/getting-started/#installation_1","text":"Create a virtual environment and install Meggie: python -m venv meggie-env source meggie-env/bin/activate pip install meggie == 1 .9.4","title":"Installation"},{"location":"user-guide/getting-started/#running-meggie_1","text":"With the venv activated, run: meggie","title":"Running Meggie"},{"location":"user-guide/getting-started/#3-installing-via-conda","text":"","title":"3. Installing via conda"},{"location":"user-guide/getting-started/#installation_2","text":"If conda is not already installed on your system, follow these steps: Visit the Miniconda download page: https://docs.conda.io/projects/conda Download the appropriate installer for your operating system: Windows : Miniconda3-latest-Windows-x86_64.exe Linux : Miniconda3-latest-Linux-x86_64.sh macOS : Miniconda3-latest-MacOSX-x86_64.pkg Run the downloaded installer and follow the on-screen instructions to complete the installation.","title":"Installation"},{"location":"user-guide/getting-started/#installing-meggie","text":"Create a new conda environment and install Meggie: conda create -n meggie-env -c conda-forge --solver libmamba meggie == 1 .9.4 conda activate meggie-env","title":"Installing Meggie"},{"location":"user-guide/getting-started/#running-meggie_2","text":"With the conda environment activated, run: meggie","title":"Running Meggie"},{"location":"user-guide/plugins/","text":"Plugins \u00b6 Meggie's capabilities can be extended through the use of plugins. These plugins are developed by the community and allow you to customize and enhance your experience with new features. Why Use Plugins? \u00b6 Plugins let you tailor Meggie to your specific research needs. They can provide new analysis options, data handling capabilities, or help optimize your existing workflows. Finding Plugins \u00b6 Below is a list of available meggie plugins found on PyPi. Plugin Name Version Last Updated Author Description meggie_difference 0.2.0 2025-03-17 CIBR Create difference objects meggie_fooof 0.4.0 2025-03-17 CIBR Enable spectral parameterization with the FOOOF package. meggie_reproduction 0.1.2 2025-03-22 CIBR Run actions based on an action log of a previous experiment meggie_statistics 0.4.0 2025-03-16 CIBR Add permutation tests for spectrums, evokeds and TFR Installing Plugins \u00b6 To install a plugin, first activate the Python environment in which Meggie is installed. Then, you can simply use pip to install the plugin of your choice: $ pip install <plugin_name> For example, if you wanted to install the \"meggie_example\" plugin, you would run: $ pip install meggie_example Need Help? \u00b6 If you have questions about selecting or installing plugins, the Meggie community is ready to help. We're all part of making Meggie a versatile and user-friendly tool for everyone.","title":"Plugins"},{"location":"user-guide/plugins/#plugins","text":"Meggie's capabilities can be extended through the use of plugins. These plugins are developed by the community and allow you to customize and enhance your experience with new features.","title":"Plugins"},{"location":"user-guide/plugins/#why-use-plugins","text":"Plugins let you tailor Meggie to your specific research needs. They can provide new analysis options, data handling capabilities, or help optimize your existing workflows.","title":"Why Use Plugins?"},{"location":"user-guide/plugins/#finding-plugins","text":"Below is a list of available meggie plugins found on PyPi. Plugin Name Version Last Updated Author Description meggie_difference 0.2.0 2025-03-17 CIBR Create difference objects meggie_fooof 0.4.0 2025-03-17 CIBR Enable spectral parameterization with the FOOOF package. meggie_reproduction 0.1.2 2025-03-22 CIBR Run actions based on an action log of a previous experiment meggie_statistics 0.4.0 2025-03-16 CIBR Add permutation tests for spectrums, evokeds and TFR","title":"Finding Plugins"},{"location":"user-guide/plugins/#installing-plugins","text":"To install a plugin, first activate the Python environment in which Meggie is installed. Then, you can simply use pip to install the plugin of your choice: $ pip install <plugin_name> For example, if you wanted to install the \"meggie_example\" plugin, you would run: $ pip install meggie_example","title":"Installing Plugins"},{"location":"user-guide/plugins/#need-help","text":"If you have questions about selecting or installing plugins, the Meggie community is ready to help. We're all part of making Meggie a versatile and user-friendly tool for everyone.","title":"Need Help?"}]}